<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fyxer Clone Email Assistant</title>
  <style>
    /* Base styles */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      /* Use uploaded image as background */
      background: url('background.png') no-repeat center center fixed;
      background-size: cover;
      min-height: 100vh;
      color: #003049;
    }
    h1 {
      margin-bottom: 10px;
    }
    h2 {
      margin-top: 30px;
      color: #444;
    }
    .card {
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    /* Glass effect container */
    .glass {
      background: rgba(255, 255, 255, 0.4);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    .email {
      /* Extend card and glass styles */
      border: 1px solid rgba(150, 245, 250, 0.4);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.5);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 16px;
      margin-bottom: 15px;
      color: #003049;
    }
    .subject {
      font-weight: bold;
      margin-bottom: 5px;
      color: #001f3f;
    }
    .snippet {
      color: #003049;
      font-size: 0.9em;
      margin-bottom: 5px;
    }
    /* Hide old draft-link styling since Draft Reply will be a button */
    .draft-link { display: none; }

    /* Buttons for account linking and actions */
    .auth-button {
      background: rgba(255, 255, 255, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 8px;
      padding: 10px 20px;
      margin-right: 10px;
      color: #003049;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }
    .auth-button:hover {
      background: rgba(255, 255, 255, 0.6);
    }

    .action-button {
      border: none;
      border-radius: 6px;
      padding: 4px 10px;
      margin-right: 6px;
      font-size: 0.85em;
      color: #fff;
      cursor: pointer;
    }
    .action-button:hover {
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <h1>Fyxer Clone Email Assistant</h1>
  <!-- Intro and account linking section -->
  <p>Connect your email account and manage your inbox.  Sign in with your email provider to fetch real messages (integration placeholders are provided since no API access is available).</p>
  <div id="account-links" class="card glass">
    <button id="connectOutlook" class="auth-button">Sign in with Outlook</button>
    <button id="connectGmail" class="auth-button">Sign in with Gmail</button>
  </div>

  <!-- Inbox container -->
  <div id="inbox"></div>

  <script>
    // OAuth configuration. Replace the placeholders below with your own client IDs
    // and ensure the redirect URI matches the location from which this page is served.
    const GOOGLE_CLIENT_ID = 'YOUR_GOOGLE_CLIENT_ID';
    const OUTLOOK_CLIENT_ID = 'YOUR_OUTLOOK_CLIENT_ID';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const GMAIL_SCOPES = 'https://www.googleapis.com/auth/gmail.readonly';
    const OUTLOOK_SCOPES = 'https://graph.microsoft.com/Mail.Read';

    // Sample data used when the user hasn't connected their account.  Once a user
    // signs in via OAuth, this array will be replaced with real messages fetched
    // from Gmail or Outlook.  Feel free to extend or modify these examples.
    const sampleEmails = [
      {
        sender: 'boss@example.com',
        subject: 'Urgent: invoice overdue',
        body: 'Hi team, we need to pay the invoice ASAP. Please handle it urgently as this invoice was due last week.',
        read: false,
        archived: false,
        snoozedUntil: null,
        flagged: false,
        reportedSpam: false,
        deleted: false
      },
      {
        sender: 'newsletter@company.com',
        subject: 'Weekly newsletter',
        body: "Hello, this is our weekly newsletter. Don't forget to update your preferences.",
        read: false,
        archived: false,
        snoozedUntil: null,
        flagged: false,
        reportedSpam: false,
        deleted: false
      },
      {
        sender: 'client@example.com',
        subject: 'Meeting next week',
        body: 'Let\'s schedule a meeting next week to discuss the project progress and timeline.',
        read: false,
        archived: false,
        snoozedUntil: null,
        flagged: false,
        reportedSpam: false,
        deleted: false
      },
      {
        sender: 'sales@vendor.com',
        subject: 'Proposal for pricing',
        body: 'Hi, I\'m sending you a proposal for our product pricing. Please review it and let me know if you have any questions.',
        read: false,
        archived: false,
        snoozedUntil: null,
        flagged: false,
        reportedSpam: false,
        deleted: false
      }
    ];

    // The main emails array used by the UI.  Initially seeded with sample data,
    // but replaced with real messages after a user signs in.
    let emails = [...sampleEmails];

    // Category definitions and keywords
    const categories = {
      Important: ['invoice', 'urgent', 'immediate', 'asap'],
      Sales: ['proposal', 'quote', 'pricing'],
      Meetings: ['calendar', 'schedule', 'meeting'],
      Spam: ['unsubscribe', 'newsletter', 'marketing', 'update']
    };

    // Classify an email based on keywords
    function classifyEmail(subject, body) {
      const text = (subject + ' ' + body).toLowerCase();
      for (const [category, keywords] of Object.entries(categories)) {
        for (const kw of keywords) {
          if (text.includes(kw)) {
            return category;
          }
        }
      }
      return 'Other';
    }

    // Action handlers for managing messages
    function markAsRead(idx) {
      emails[idx].read = true;
      buildInbox();
    }
    function archiveEmail(idx) {
      emails[idx].archived = true;
      buildInbox();
    }
    function snoozeEmail(idx) {
      const daysStr = prompt('Snooze for how many days?', '1');
      const days = parseInt(daysStr);
      if (!isNaN(days) && days > 0) {
        const now = new Date();
        emails[idx].snoozedUntil = now.getTime() + days * 24 * 60 * 60 * 1000;
      }
      buildInbox();
    }
    function deleteEmail(idx) {
      if (confirm('Are you sure you want to delete this email?')) {
        emails[idx].deleted = true;
        buildInbox();
      }
    }
    function flagEmail(idx) {
      emails[idx].flagged = !emails[idx].flagged;
      buildInbox();
    }
    function reportSpam(idx) {
      if (!emails[idx].reportedSpam) {
        emails[idx].reportedSpam = true;
        emails[idx].category = 'Spam';
      }
      buildInbox();
    }

    // Shorten the body for display in the inbox
    function makeSnippet(text, maxLength = 80) {
      if (text.length <= maxLength) return text;
      return text.slice(0, maxLength).trim() + '…';
    }

    function groupEmails() {
      const grouped = { Important: [], Sales: [], Meetings: [], Spam: [], Archived: [], Other: [] };
      const now = Date.now();
      emails.forEach((email, idx) => {
        email.idx = idx;
        // Skip deleted emails
        if (email.deleted) return;
        // Skip snoozed emails until due date
        if (email.snoozedUntil && email.snoozedUntil > now) return;
        // Determine category unless archived or reported spam
        let category = email.category;
        if (!category) {
          category = classifyEmail(email.subject, email.body);
        }
        if (email.reportedSpam) {
          category = 'Spam';
        }
        if (email.archived) {
          category = 'Archived';
        }
        email.category = category;
        email.snippet = makeSnippet(email.body);
        if (!grouped[category]) grouped[category] = [];
        grouped[category].push(email);
      });
      return grouped;
    }

    function buildInbox() {
      const container = document.getElementById('inbox');
      container.innerHTML = '';
      const grouped = groupEmails();
      for (const category of ['Important', 'Sales', 'Meetings', 'Spam', 'Archived', 'Other']) {
        const list = grouped[category];
        const h2 = document.createElement('h2');
        h2.textContent = category;
        container.appendChild(h2);
        if (!list || list.length === 0) {
          const p = document.createElement('p');
          p.textContent = 'No emails in this category.';
          container.appendChild(p);
          continue;
        }
        list.forEach(email => {
          const div = document.createElement('div');
          div.className = 'email';
          const subjectDiv = document.createElement('div');
          subjectDiv.className = 'subject';
          subjectDiv.textContent = email.subject + (email.flagged ? ' ★' : '');
          if (email.read) {
            subjectDiv.style.opacity = '0.7';
          }
          div.appendChild(subjectDiv);
          const snippetDiv = document.createElement('div');
          snippetDiv.className = 'snippet';
          snippetDiv.textContent = email.snippet;
          div.appendChild(snippetDiv);
          // Actions
          const actionsDiv = document.createElement('div');
          actionsDiv.style.marginTop = '8px';
          // Draft reply as a button
          const draftBtn = document.createElement('button');
          draftBtn.className = 'action-button';
          draftBtn.textContent = 'Draft Reply';
          draftBtn.style.backgroundColor = '#33c0dd';
          draftBtn.onclick = () => {
            window.location.href = 'reply.html?idx=' + email.idx;
          };
          actionsDiv.appendChild(draftBtn);
          // Additional action buttons with specific colours
          const actions = [
            { label: email.read ? '✓ Read' : 'Mark Read', handler: () => markAsRead(email.idx), color: '#38a169' },
            { label: 'Archive', handler: () => archiveEmail(email.idx), color: '#6c757d' },
            { label: 'Snooze', handler: () => snoozeEmail(email.idx), color: '#f6b26b' },
            { label: 'Delete', handler: () => deleteEmail(email.idx), color: '#e63946' },
            { label: email.flagged ? 'Unflag' : 'Flag', handler: () => flagEmail(email.idx), color: '#9b5de5' },
            { label: 'Report Spam', handler: () => reportSpam(email.idx), color: '#dd2c00' }
          ];
          actions.forEach(action => {
            const btn = document.createElement('button');
            btn.className = 'action-button';
            btn.textContent = action.label;
            btn.style.backgroundColor = action.color;
            btn.onclick = action.handler;
            actionsDiv.appendChild(btn);
          });
          div.appendChild(actionsDiv);
          container.appendChild(div);
        });
      }
    }

    // ============================
    // OAuth helper functions
    // ============================

    // Generate a random string for the OAuth state parameter to mitigate CSRF
    function generateRandomString(length = 16) {
      const charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += charset.charAt(Math.floor(Math.random() * charset.length));
      }
      return result;
    }

    // Begin Google OAuth (implicit grant). Redirects the user to Google's
    // authorization endpoint with the appropriate parameters. After the user
    // completes the consent flow, Google will redirect back with an access token
    // in the URL hash (#access_token=...).
    function authenticateGmail() {
      const state = generateRandomString();
      localStorage.setItem('gmail_state', state);
      const authUrl = 'https://accounts.google.com/o/oauth2/v2/auth' +
        '?client_id=' + encodeURIComponent(GOOGLE_CLIENT_ID) +
        '&redirect_uri=' + encodeURIComponent(REDIRECT_URI) +
        '&response_type=token' +
        '&scope=' + encodeURIComponent(GMAIL_SCOPES) +
        '&state=' + encodeURIComponent(state);
      window.location.href = authUrl;
    }

    // Begin Outlook (Microsoft) OAuth (implicit grant). Redirects the user to
    // Microsoft’s authorization endpoint. After consent, an access token will
    // arrive in the URL hash (#access_token=...).
    function authenticateOutlook() {
      const state = generateRandomString();
      localStorage.setItem('outlook_state', state);
      const authUrl = 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize' +
        '?client_id=' + encodeURIComponent(OUTLOOK_CLIENT_ID) +
        '&redirect_uri=' + encodeURIComponent(REDIRECT_URI) +
        '&response_type=token' +
        '&scope=' + encodeURIComponent(OUTLOOK_SCOPES) +
        '&response_mode=fragment' +
        '&state=' + encodeURIComponent(state);
      window.location.href = authUrl;
    }

    // Parse the URL fragment returned from the OAuth servers and store access
    // tokens accordingly. Once tokens are saved, trigger message fetches.
    function handleAuthResponse() {
      const fragment = window.location.hash.substring(1);
      if (!fragment) return;
      const params = new URLSearchParams(fragment);
      const accessToken = params.get('access_token');
      const state = params.get('state');
      if (!accessToken || !state) return;
      // Clear the fragment to avoid exposing the token
      window.history.replaceState({}, document.title, window.location.pathname);
      // Identify which provider returned the token based on the stored state
      if (state === localStorage.getItem('gmail_state')) {
        localStorage.setItem('gmail_access_token', accessToken);
        fetchGmailMessages();
      } else if (state === localStorage.getItem('outlook_state')) {
        localStorage.setItem('outlook_access_token', accessToken);
        fetchOutlookMessages();
      }
    }

    // Retrieve a batch of recent messages from the Gmail API using the stored
    // access token.  This function populates the global `emails` array and
    // rebuilds the inbox UI.  It fetches only a handful of messages for demo
    // purposes; in a production app you might implement pagination.
    async function fetchGmailMessages() {
      const token = localStorage.getItem('gmail_access_token');
      if (!token) return;
      try {
        // List message IDs
        const listResp = await fetch('https://www.googleapis.com/gmail/v1/users/me/messages?maxResults=10', {
          headers: { 'Authorization': 'Bearer ' + token }
        });
        const listData = await listResp.json();
        if (!listData.messages) {
          console.warn('No Gmail messages returned.');
          return;
        }
        const messages = [];
        for (const msg of listData.messages) {
          const detailResp = await fetch('https://www.googleapis.com/gmail/v1/users/me/messages/' + msg.id + '?format=metadata&metadataHeaders=Subject&metadataHeaders=From', {
            headers: { 'Authorization': 'Bearer ' + token }
          });
          const detail = await detailResp.json();
          // Extract subject and sender from the headers
          const headers = detail.payload.headers || [];
          const subjHeader = headers.find(h => h.name === 'Subject');
          const fromHeader = headers.find(h => h.name === 'From');
          const subject = subjHeader ? subjHeader.value : '(no subject)';
          const sender = fromHeader ? fromHeader.value : '';
          // Gmail API provides a snippet summary for each message
          const body = detail.snippet || '';
          messages.push({
            sender: sender,
            subject: subject,
            body: body,
            read: false,
            archived: false,
            snoozedUntil: null,
            flagged: false,
            reportedSpam: false,
            deleted: false
          });
        }
        // Replace the global emails array with fetched messages
        emails = messages;
        buildInbox();
      } catch (err) {
        console.error('Error fetching Gmail messages:', err);
      }
    }

    // Retrieve a batch of recent messages from the Microsoft Graph API.  This
    // function requires that the Mail.Read scope be granted and populates the
    // `emails` array accordingly.
    async function fetchOutlookMessages() {
      const token = localStorage.getItem('outlook_access_token');
      if (!token) return;
      try {
        const resp = await fetch('https://graph.microsoft.com/v1.0/me/mailFolders/inbox/messages?$top=10', {
          headers: { 'Authorization': 'Bearer ' + token }
        });
        const data = await resp.json();
        if (!data.value) {
          console.warn('No Outlook messages returned.');
          return;
        }
        const messages = data.value.map(item => {
          return {
            sender: item.from && item.from.emailAddress ? item.from.emailAddress.address : '',
            subject: item.subject || '(no subject)',
            body: item.bodyPreview || '',
            read: item.isRead || false,
            archived: false,
            snoozedUntil: null,
            flagged: item.flag && item.flag.flagStatus === 'flagged',
            reportedSpam: false,
            deleted: false
          };
        });
        emails = messages;
        buildInbox();
      } catch (err) {
        console.error('Error fetching Outlook messages:', err);
      }
    }

    // Attach OAuth functions to the sign-in buttons
    document.getElementById('connectOutlook').addEventListener('click', authenticateOutlook);
    document.getElementById('connectGmail').addEventListener('click', authenticateGmail);

    // On page load, check if we're returning from an OAuth redirect and handle
    // any tokens in the URL fragment.  Then build the inbox with either the
    // sample data or previously fetched messages.
    handleAuthResponse();
    buildInbox();
  </script>
</body>
</html>